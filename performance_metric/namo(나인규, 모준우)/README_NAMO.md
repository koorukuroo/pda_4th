# ğŸš© Namo íŒ€ ì¸ìŠ¤í„´ìŠ¤ ë³„ ì„±ëŠ¥ë¹„êµ

## ê° ì¸ìŠ¤í„´ìŠ¤ì˜ íŠ¹ì§•

1. **m4**: ë²”ìš© ì‚¬ìš©ì„ ìœ„í•œ ì¸ìŠ¤í„´ìŠ¤.
   ì›¹ ì„œë²„ ë° ì½”ë“œ ë¦¬í¬ì§€í† ë¦¬ì™€ ê°™ì´ ì´ëŸ¬í•œ ë¦¬ì†ŒìŠ¤ë¥¼ ë™ë“±í•œ ë¹„ìœ¨ë¡œ ì‚¬ìš©í•˜ëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ì— ì í•©í•©ë‹ˆë‹¤.
2. **i4i**: ì¸í…” Xeon í”„ë¡œì„¸ì„œì™€ 4GBì˜ ì¸ìŠ¤í„´ìŠ¤ ë©”ëª¨ë¦¬ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
3. **t2**: ì¼ë°˜ìš© í‹° ëª¨ë“œ ì¸ìŠ¤í„´ìŠ¤ë¡œ ì €ë ´í•œ ë¹„ìš©ìœ¼ë¡œ ì œê³µë©ë‹ˆë‹¤.
4. **r2**: ë©”ëª¨ë¦¬ ì¤‘ì‹¬ì˜ ìµœì í™”ëœ ì¸ìŠ¤í„´ìŠ¤ë¡œ ë©”ëª¨ë¦¬ ë° CPUê°€ í–¥ìƒë˜ì—ˆìŠµë‹ˆë‹¤.
5. **c5**: ì»´í“¨íŒ… ì§‘ì¤‘í˜• ì›Œí¬ë¡œë“œë¥¼ ìœ„í•œ ìµœì‹  ì„¸ëŒ€ì˜ ì¸ìŠ¤í„´ìŠ¤ì…ë‹ˆë‹¤.
6. **d2**: ë””ìŠ¤í¬ ì§‘ì¤‘í˜• ì›Œí¬ë¡œë“œë¥¼ ìœ„í•œ ëŒ€ìš©ëŸ‰ ë””ìŠ¤í¬ë¥¼ ì œê³µí•˜ëŠ” ì¸ìŠ¤í„´ìŠ¤ì…ë‹ˆë‹¤.

## ì‹¤í–‰ ë°©ë²•

1. ê° ì¸ìŠ¤í„´ìŠ¤ì— ì ‘ì†
2. ë¦¬ëˆ…ìŠ¤ CLIì—ì„œ ì›í•˜ëŠ” í´ë”ë¥¼ ë§Œë“¤ê³ , C íŒŒì¼ ìƒì„±
3. C íŒŒì¼ì„ ì»´íŒŒì¼í•˜ì—¬ ì‹¤í–‰
4. ê° ì‹¤í–‰ ì‹œê°„ì„ ë¹„êµ/ë¶„ì„ ë° ì‹œê°í™”

# ì£¼ì œ

## ì„±ëŠ¥ ì¸¡ì •ì„ ìœ„í•œ C ì–¸ì–´ ì‹¤í–‰

ë³¸ í”„ë¡œì íŠ¸ëŠ” ì—¬ëŸ¬ ì¸ìŠ¤í„´ìŠ¤ì—ì„œ C ì–¸ì–´ë¡œ ì‘ì„±ëœ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ì½”ë“œì˜ ì‹¤í–‰ ì‹œê°„ì„ ì¸¡ì •í•˜ê³ ì í•©ë‹ˆë‹¤. ê° ì¸ìŠ¤í„´ìŠ¤ëŠ” ë‹¤ìŒê³¼ ê°™ì€ íŠ¹ì§•ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.

<br>

### 2. ì¸ìŠ¤í„´ìŠ¤ ìœ í˜•

`c5`&nbsp; / &nbsp; `i4i`&nbsp; /&nbsp; `m4` / &nbsp; `t2` / &nbsp; `r2` / &nbsp; `d2`

### ìœ í˜•ë³„ í¬ê¸°

- CPUë³„ ë¹„êµë¥¼ ìœ„í•´ ìœ í˜•ë³„ í¬ê¸°ëŠ” xlargeë¡œ í†µì¼

## ì¸ìŠ¤í„´ìŠ¤ í™˜ê²½

- OS
  - Canonical, Ubuntu, 22.04, ams64 jammy image
- ìŠ¤í† ë¦¬ì§€
  - (32G, gp3)

<br>

## ê²°ê³¼ ì‹œê°í™”

ê° ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ì‹¤í–‰í•œ ì½”ë“œì˜ ì‹¤í–‰ ì‹œê°„ì„ ì‹œê°í™”í•˜ì—¬ ë¹„êµí•©ë‹ˆë‹¤. ë˜í•œ ê° ì¸ìŠ¤í„´ìŠ¤ì˜ ì˜¨ë””ë§¨ë“œ ìš”ê¸ˆì„ ì‹œê°í™”í•˜ì—¬ ë¹„êµí•©ë‹ˆë‹¤

### ì¸ìŠ¤í„´ìŠ¤ ë³„ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ì‹¤í–‰ì‹œê°„

![alt text](result_image/InstanceType.png)

### ì¸ìŠ¤í„´ìŠ¤ ë³„ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ì´ ì‹¤í–‰ì‹œê°„

![alt text](result_image/ExecutionTime.png)

### ì¸ìŠ¤í„´ìŠ¤ ë³„ ì˜¨ë””ë§¨ë“œ ê°€ê²©(kor)

![alt text](result_image/TotalPrice.png)

# ê²°ë¡ 

- ì„±ëŠ¥ ë¹„êµì‹œ ì‚¬ìš©í•œ ì½”ë“œì˜ ì¸ì•„ì›ƒí’‹ì´ ë§ì§€ ì•Šì•„ì„œ
  ìœ ì˜ë¯¸í•œ ë¹„êµê°€ ì–´ë µë‹¤.
  ì¶”í›„ ë” ë³µì¡í•œ ì‹œìŠ¤í…œì„ í†µí•´ í™•ì¸í•  ì˜ˆì •
- ì—°ì‚°ì˜ ì„±ëŠ¥ì´ ê°€ì¥ í¬ê²Œ ê³ ë ¤ë˜ëŠ” ìƒí™©ì—ì„  c5ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´
  ì‹¤í–‰ì‹œê°„ ì¸¡ë©´ì—ì„œ íš¨ìœ¨ì ì´ë‹¤.

<br>

# í¬ë¡¤ë§ ì½”ë“œ

```c
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <memory.h>
#define ARR_SIZE 100000

//Create 100000 random number
void random_arr(int random_number[]) {
	int temp;
	int check = 0;
	for (int i = 0; i < ARR_SIZE; i++) {
		while (1) {
			temp = ((int)rand() << 16) | ((int)rand());
			check = 0;
			for (int j = 0; j <= i; j++) {
				if (random_number[j] != temp) {
					continue;
				}
				else {
					check += 1;
					break;
				}
			}
			if (check == 0) {
				random_number[i] = temp;
				break;
			}
		}
	}
}

//Insertion Sort
void insertion_sort(int random_number[]) {
	int j = 0;
	for (int i = 1; i < ARR_SIZE; i++) {
		int current_val = random_number[i];
		for (j = i - 1; j >= 0; j--) {
			if (random_number[j] > current_val) {
				random_number[j + 1] = random_number[j];
			}
			else {
				break;
			}
		}
		random_number[j + 1] = current_val;
	}
}

//Quick Sort
void quick_sort(int random_number[], int start, int last) {
	if (start >= last) {
		return;
	}
	int pivot = start;
	int left = pivot + 1;
	int right = last;
	int temp;
	while (left <= right) {
		while (left <= last && random_number[left] <= random_number[pivot]) {
			left += 1;
		}
		while (right > start && random_number[right] >= random_number[pivot]) {
			right -= 1;
		}

		if (left > right) {
			temp = random_number[right];
			random_number[right] = random_number[pivot];
			random_number[pivot] = temp;
		}
		else {
			temp = random_number[left];
			random_number[left] = random_number[right];
			random_number[right] = temp;
		}
	}
	quick_sort(random_number, start, right - 1);
	quick_sort(random_number, right + 1, last);
}

//Merge Sort
void merge(int random_number[], int sorted[], int start, int mid, int last) {
	int left_list_index = start;
	int right_list_index = mid + 1;
	int sorted_index = start;

	int remain_list;
	while (left_list_index <= mid && right_list_index <= last) {
		if (random_number[left_list_index] <= random_number[right_list_index]) {
			sorted[sorted_index++] = random_number[left_list_index++];
		}
		else {
			sorted[sorted_index++] = random_number[right_list_index++];
		}
	}

	if (left_list_index > mid) {
		remain_list = right_list_index;
		while (remain_list <= last) {
			sorted[sorted_index++] = random_number[remain_list];
			remain_list += 1;
		}
	}
	else {
		remain_list = left_list_index;
		while (remain_list <= mid) {
			sorted[sorted_index++] = random_number[remain_list];
			remain_list += 1;
		}
	}
	for (int l = start; l <= last; l++) {
		random_number[l] = sorted[l];
	}
}

void merge_sort(int random_number[], int sorted[], int start, int last) {
	if (start < last) {
		int mid = (start + last) / 2;
		merge_sort(random_number, sorted, start, mid);
		merge_sort(random_number, sorted, mid + 1, last);
		merge(random_number, sorted, start, mid, last);
	}
}

//Heap Sort
void swap(int* a, int* b) {
	int temp = *a;
	*a = *b;
	*b = temp;
}

void heapify(int random_number[], int index, int size) {
	int left = 2 * index + 1;
	int right = 2 * index + 2;
	int max_index = index;
	if (left < size && random_number[left] > random_number[max_index]) {
		max_index = left;
	}
	if (right < size && random_number[right] > random_number[max_index]) {
		max_index = right;
	}

	if (max_index != index) {
		swap(&random_number[index], &random_number[max_index]);
		heapify(random_number, max_index, size);
	}

}
void heap_sort(int random_number[], int size) {

	for (int i = size / 2 - 1; i >= 0; i--) {
		heapify(random_number, i, size);
	}

	for (int i = size - 1; i >= 0; i--) {
		swap(&random_number[0], &random_number[i]);
		heapify(random_number, 0, i);
	}
}

//Selection
int Partition(int arr[], int left, int right)
{
	int pos = arr[left];
	int low = left + 1, high = right;
	while (low <= high)
	{
		while (low <= right && arr[low] <= pos)
		{
			low++;
		}
		while (high >= (left + 1) && arr[high] >= pos)
		{
			high--;
		}
		if (low <= high)
		{
			swap(&arr[low], &arr[high]);
		}
	}
	swap(&arr[left], &arr[high]);
	return high;
}

int selection(int arr[], int left, int right, int select){

	if (select > 0 && select <= right - left + 1)
	{
		int pos = Partition(arr, left, right);

		if (pos - left == select - 1)
		{
			return arr[pos];
		}
		else if (pos - left > select - 1)
		{
			return selection(arr, left, pos - 1, select);
		}
		else
		{
			return selection(arr, pos + 1, right, select - pos + left - 1);
		}
	}
	return -1;
}


int main(void) {
	clock_t time;
	int random_number[ARR_SIZE];
	random_arr(random_number);

	int temp[ARR_SIZE];
	int *sorted = (int *)malloc(sizeof(int) * ARR_SIZE);

    clock_t all_time;
    all_time = clock();
	//Insertion Sort
	memcpy(temp, random_number, sizeof(random_number));
	time = clock();
	insertion_sort(temp);
	time = clock() - time;
	printf("Insertion Sort Running Time (O(n^2)): %lf\n", time / 1000.0);

	//Quick Sort
	memcpy(temp, random_number, sizeof(random_number));
	time = clock();
	quick_sort(temp, 0, ARR_SIZE-1);
	time = clock() - time;
	printf("Quick Sort Running Time (O(n*log(n))): %lf\n", time / 1000.0);

	//Merge Sort
	memcpy(temp, random_number, sizeof(random_number));
	time = clock();
	merge_sort(temp, sorted, 0, ARR_SIZE - 1);
	time = clock() - time;
	printf("Merge Sort Running Time (O(n*log(n))): %lf\n", time / 1000.0);

	//Heap Sort
	memcpy(temp, random_number, sizeof(random_number));
	time = clock();
	heap_sort(temp, ARR_SIZE);
	time = clock() - time;
	printf("Heap Sort Running Time (O(n*log(n))): %lf\n", time / 1000.0);

	//Selection
	memcpy(temp, random_number, sizeof(random_number));
	time = clock();
	int answer = selection(temp, 0, ARR_SIZE - 1, ARR_SIZE / 2);
	time = clock() - time;
	printf("Selection Running Time (O(n)): %lf -> ", time / 1000.0);
	if (answer == -1) {
		printf("Fail Searching\n");
	}
	else {
		printf("(Median: %d)\n", answer);
	}
    all_time = clock() - all_time;
    printf("All Time: %lf -> ", all_time / 1000.0);
	return 0;
}
```

#ì‹œê°í™” ì½”ë“œ

```python

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd


# ì˜ˆì œ ë°ì´í„° í”„ë ˆì„ ìƒì„±
data = {
    'Instance Type': ['c5.xlarge', 'i4i.xlarge', 'm4.xlarge', 't2.xlarge','d2.2xlarge','r4.xlarge'],

    'Insertion': [6.10775, 6.14215, 9.572034, 8.62943, 8.91265,8.595115],
    'Quick': [12.83, 13.179, 20.087, 16.697,16.956,16.651],
    'Merge': [16.83, 15.807, 26.43, 20.375,20.735,20.274],
    'Heap': [25, 26.73, 40.75, 34.258,35.412,34.2],
    'Selection': [2.12, 1.987, 3.282, 2.54, 2.55,2.499],

}
instance_types = ['c5.xlarge', 'i4i.xlarge', 'm4.xlarge', 't2.xlarge','d2.2xlarge','r4.xlarge']
total_execution_times = [6165, 6199, 9622, 8703,8988,8669]

# ë§‰ëŒ€ ê·¸ë˜í”„ ì‹œê°í™”
plt.bar(instance_types, total_execution_times, color='skyblue')
plt.xlabel('Instance Type')
plt.ylabel('Total Execution Time')
plt.title('Execution Time by Instance Type')
plt.xticks(rotation=45)
plt.show()

On_demand_Price_KOR= [230.4, 483.6, 295.2, 276.48,319.2,2025.6]


plt.bar(instance_types, On_demand_Price_KOR, color='skyblue')
plt.xlabel('Instance Type')
plt.ylabel('Total Price')
plt.title('Total by Instance Type')
plt.xticks(rotation=45)
plt.show()

plt.figure(figsize=(10, 6))

# ê° ë°ì´í„° ì‹œë¦¬ì¦ˆì— ëŒ€í•´ ì„  ê·¸ë˜í”„ ê·¸ë¦¬ê¸°
for column in df.columns[1:]:
    plt.plot(df['Instance Type'], df[column], marker='o', label=column)

plt.title('Instance Type Comparison')
plt.xlabel('Instance Type')
plt.ylabel('Time')
plt.legend()
plt.grid(True)
plt.show()


# Team

- Na In Gyu :
  - ì•Œê³ ë¦¬ì¦˜ ì½”ë“œ ì‘ì„±
  - d2,m4,t2,r4 ì‹¤í–‰
  - ì„±ëŠ¥ ë¶„ì„
- Mo Joon Woo :
  - c5,i4i ì‹¤í–‰
  - README ì‘ì„±
  - ë°œí‘œ

### ì¶œì²˜

ì•ì„  íŒ€ì˜ README.md ë¥¼ ì°¸ê³ í–ˆìŠµë‹ˆë‹¤.
```
